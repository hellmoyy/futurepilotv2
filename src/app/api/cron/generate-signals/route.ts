import { NextRequest, NextResponse } from 'next/server';
import { SignalEngine, signalBroadcaster } from '@/lib/signal-center';
import { fetchMultiTimeframeCandlesWithRetry, validateCandles } from '@/lib/binance/candleFetcher';
import connectDB from '@/lib/mongodb';
import SignalCenterSignal from '@/models/SignalCenterSignal';

export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';
export const maxDuration = 60;

let stats = { 
  totalRuns: 0, 
  successfulRuns: 0, 
  failedRuns: 0, 
  signalsGenerated: 0, 
  lastRun: 0, 
  lastError: '' 
};

export async function POST(req: NextRequest) {
  const startTime = Date.now();
  
  try {
    // üß™ Check for force mode (testing)
    const body = await req.json().catch(() => ({}));
    const forceGenerate = body.forceGenerate === true;
    
    console.log('ü§ñ SIGNAL GENERATOR START' + (forceGenerate ? ' (FORCE MODE)' : ''));
    stats.totalRuns++;
    stats.lastRun = startTime;
    
    const symbol = 'BTCUSDT';
    const candles = await fetchMultiTimeframeCandlesWithRetry(symbol, 100, 3, 1000);
    
    console.log(`‚úÖ Candles fetched`);
    
    if (!validateCandles(candles['1m']) || !validateCandles(candles['3m']) || !validateCandles(candles['5m'])) {
      throw new Error('Invalid candles data');
    }
    
    // üî• NEW: Load config from database (Configuration tab)
    console.log('üìã Loading active config from database...');
    const engine = await SignalEngine.createFromDatabase();
    
    // üß™ FORCE MODE: Bypass all filters and generate signal
    let result;
    if (forceGenerate) {
      result = await engine.forceGenerateSignal(symbol, candles['1m']);
    } else {
      result = await engine.analyze(symbol, candles['1m'], candles['3m'], candles['5m']);
    }
    
    if (!result.signal) {
      console.log('‚ö†Ô∏è  No signal generated');
      stats.successfulRuns++;
      return NextResponse.json({ success: true, signal: null, message: 'No signal', stats });
    }
    
    const signal = result.signal;
    console.log(`üéØ Signal: ${signal.action} ${signal.symbol}`);
    
    // Get connected bots count
    const connectedBots = signalBroadcaster.getStats().connectedBots || 0;
    
    // üíæ Save signal to MongoDB
    await connectDB();
    const savedSignal = await SignalCenterSignal.create({
      signalId: signal.id,
      symbol: signal.symbol,
      action: signal.action === 'BUY' ? 'LONG' : 'SHORT', // Convert BUY/SELL to LONG/SHORT
      strength: signal.strength,
      confidence: signal.confidence / 100, // Convert 0-100 to 0-1
      entryPrice: signal.entryPrice,
      stopLoss: signal.stopLoss,
      takeProfit: signal.takeProfit,
      leverage: 10, // Default from config
      riskPercent: 0.02, // 2% default
      timeframe: '1m',
      indicators: {
        rsi: signal.indicators.rsi,
        macdHistogram: signal.indicators.macd.histogram,
        ema9: signal.indicators.ema.fast,
        ema21: signal.indicators.ema.slow,
        adx: signal.indicators.adx,
        atr: signal.volatility,
        volumeRatio: signal.indicators.volume.ratio,
      },
      metadata: {
        marketRegime: signal.marketRegime === 'NEUTRAL' ? 'TESTING' : signal.marketRegime,
        volumeConfirmation: true,
        multiTimeframeConfirmed: false,
        entryConfirmedCandles: 0,
        expectedDuration: 5, // minutes
      },
      reason: signal.reason || 'Signal generated by futures-scalper strategy',
      strategy: signal.strategy || 'futures-scalper',
      status: signal.status,
      createdAt: new Date(signal.timestamp),
      expiresAt: new Date(signal.expiresAt),
      connectedBotsCount: connectedBots, // Save connected bots count
      executedBotsCount: 0, // Will be updated when bots execute
      skippedBotsCount: 0, // Will be updated when bots skip
    });
    console.log('üíæ Signal saved to database:', savedSignal._id);
    console.log(`üìä Connected bots at broadcast: ${connectedBots}`);
    
    // üì° Broadcast signal via SSE
    signalBroadcaster.broadcast(signal);
    
    stats.successfulRuns++;
    stats.signalsGenerated++;
    
    console.log(`‚úÖ Done (${Date.now() - startTime}ms)`);
    
    return NextResponse.json({ success: true, signal, stats });
    
  } catch (error: any) {
    console.error('‚ùå Error:', error.message);
    stats.failedRuns++;
    stats.lastError = error.message;
    return NextResponse.json({ success: false, error: error.message, stats }, { status: 500 });
  }
}

export async function GET(req: NextRequest) {
  return NextResponse.json({ 
    success: true, 
    status: 'ready', 
    stats, 
    broadcasterStats: signalBroadcaster.getStats() 
  });
}